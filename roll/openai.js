"use strict";
if (!process.env.OPENAI_SWITCH) return;
const { encode } = require('gpt-tokenizer');
const OpenAIApi = require('openai');
const dotenv = require('dotenv');
const handleMessage = require('../modules/discord/handleMessage');
dotenv.config({ override: true });
const fetch = require('node-fetch');
const fs = require('fs').promises;
const fs2 = require('fs');
const VIP = require('../modules/veryImportantPerson');
const GPT3 = { name: "gpt-4o-mini", token: 12000, input_price: 0.0018, output_price: 0.0072 };
const GPT4 = { name: "gpt-4o", token: 16000, input_price: 0.06, output_price: 0.18 };
const DALLE3 = { name: "dall-e-2", price: 0.20, size1: "1024x1024", size2: "512√ó512" };
const adminSecret = process.env.ADMIN_SECRET;
const TRANSLATE_LIMIT_PERSONAL = [500, 100000, 150000, 150000, 150000, 150000, 150000, 150000];
const variables = {};
const { SlashCommandBuilder } = require('discord.js');
const gameName = function () {
    return '„ÄêOpenAi„Äë'
}

const gameType = function () {
    return 'funny:openai:hktrpg'
}
const prefixs = function () {
    //[mainMSG[0]ÁöÑprefixs,mainMSG[1]ÁöÑprefixs,   <---ÈÄôË£°ÊòØ‰∏ÄÂ∞ç  
    //mainMSG[0]ÁöÑprefixs,mainMSG[1]ÁöÑprefixs  ]  <---ÈÄôË£°ÊòØ‰∏ÄÂ∞ç
    //Â¶ÇÂâçÈù¢ÊòØ /^1$/ig, ÂæåÈù¢ÊòØ/^1D100$/ig, Âç≥ prefixs ËÆäÊàê 1 1D100 
    ///^(?=.*he)(?!.*da).*$/ig
    return [{
        first: /^([.]ai)|(^[.]aimage)|(^[.]ait)|(^[.]ai4)|(^[.]ait4)|(^[.]doc)$/i,
        second: null
    }]
}
const getHelpMessage = function () {
    return `„Äêü§ñOpenAIÂä©Êâã„Äë
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üó£Ô∏èÂ∞çË©±ÂäüËÉΩ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ ‚Ä¢ .ai [Ë®äÊÅØ]
‚îÇ ‚Ä¢ ÊàñÂõûË¶Ü(Reply)Ë¶ÅË®éË´ñÁöÑÂÖßÂÆπ
‚îÇ ‚Ä¢ ‰ΩøÁî®gpt-4o-miniÊ®°Âûã
‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üìùÁøªË≠ØÂäüËÉΩ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ ‚Ä¢ .ait [ÊñáÂ≠óÂÖßÂÆπ]
‚îÇ ‚Ä¢ Êàñ‰∏äÂÇ≥.txtÈôÑ‰ª∂
‚îÇ ‚Ä¢ ‰ΩøÁî®gpt-4o-miniÈÄ≤Ë°åÁøªË≠Ø
‚îÇ ‚Ä¢ ËΩâÊèõÁÇ∫Ê≠£È´î‰∏≠Êñá
‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üìÑÊñá‰ª∂ÂàÜÊûêÂäüËÉΩ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ ‚Ä¢ .doc [Ê™îÊ°à]
‚îÇ ‚Ä¢ ‰∏äÂÇ≥Êñá‰ª∂(PDF„ÄÅDOCXÁ≠â)
‚îÇ ‚Ä¢ ÂàÜÊûê‰∏¶ËΩâÊèõÊñá‰ª∂Ê†ºÂºè
‚îÇ ‚Ä¢ ÊîØÊè¥ÂåØÂá∫ÁÇ∫JSON„ÄÅMarkdownÁ≠â
‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚ö†Ô∏è‰ΩøÁî®ÈôêÂà∂ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ ‰∏ÄËà¨Áî®Êà∂:
‚îÇ „ÄÄ‚Ä¢ ÊñáÂ≠ó‰∏äÈôê500Â≠ó
‚îÇ
‚îÇ VIPÁî®Êà∂:
‚îÇ „ÄÄ‚Ä¢ ‰∫´ÊúâÊõ¥È´òÊñáÂ≠ó‰∏äÈôê
‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üìåÊ≥®ÊÑè‰∫ãÈ†Ö ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ ‚Ä¢ AIÁøªË≠ØÈúÄË¶ÅËôïÁêÜÊôÇÈñì
‚îÇ ‚Ä¢ 10000Â≠óÂèØËÉΩÈúÄÊôÇ10ÂàÜÈêò‰ª•‰∏ä
‚îÇ ‚Ä¢ Á≥ªÁµ±ÂèØËÉΩÂõ†ÈåØË™§ËÄåÁøªË≠ØÂ§±Êïó
‚îÇ ‚Ä¢ Ë∂ÖÈÅé1900Â≠óÂ∞á‰ª•.txtÊ™îÊ°àÂõûË¶Ü
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ`
}
const initialize = function () {
    return variables;
}

const rollDiceCommand = async function ({
    inputStr,
    mainMsg,
    groupid,
    discordMessage,
    userid,
    discordClient,
    userrole,
    botname,
    displayname,
    channelid,
    displaynameDiscord,
    membercount
}) {
    let rply = {
        default: 'on',
        type: 'text',
        text: ''
    };
    switch (true) {
        case /^.doc/i.test(mainMsg[0]): {
            if (!adminSecret) return rply;
            if (userid !== adminSecret) return rply;
            let lv = await VIP.viplevelCheckUser(userid);
            if (lv < 1) {
                rply.text = `ÈÄôÊòØÂØ¶È©óÂäüËÉΩÔºåÁèæÂú®Âè™ÊúâVIPÊâçËÉΩ‰ΩøÁî®Ôºå\nÊîØÊè¥HKTRPGÂèäÂçáÁ¥öË´ãÂà∞\nhttps://www.patreon.com/hktrpg`
                return rply;
            }
            
            rply.text = await doclingHandler.handleDocument(inputStr, discordMessage, discordClient);
            rply.quotes = true;
            return rply;
        }
        case /^.ait/i.test(mainMsg[0]): {
            const mode = mainMsg[0].includes('4') ? GPT4 : GPT3;
            if (mode === GPT4) {
                if (!adminSecret) return rply;
                if (userid !== adminSecret) return rply;
            }
            const { filetext, sendfile, text } = await translateAi.handleTranslate(inputStr, discordMessage, discordClient, userid, mode);
            filetext && (rply.fileText = filetext);
            sendfile && (rply.fileLink = [sendfile]);
            text && (rply.text = text);
            rply.quotes = true;
            return rply;
        }
        case /^\S/.test(mainMsg[1]) && /^.aimage$/i.test(mainMsg[0]): {
            if (!adminSecret) return rply;
            if (userid !== adminSecret) return rply;
            let lv = await VIP.viplevelCheckUser(userid);
            if (lv < 1) {
                rply.text = `ÈÄôÊòØÂØ¶È©óÂäüËÉΩÔºåÁèæÂú®Âè™ÊúâVIPÊâçËÉΩ‰ΩøÁî®Ôºå\nÊîØÊè¥HKTRPGÂèäÂçáÁ¥öË´ãÂà∞\nhttps://www.patreon.com/hktrpg`
                return rply;
            }

            rply.text = await imageAi.handleImageAi(inputStr);
            rply.quotes = true;
            return rply;
        }
        case /^\S/.test(mainMsg[1]): {
            const mode = mainMsg[0].includes('4') ? GPT4 : GPT3;
            if (mode === GPT4) {
                if (!adminSecret) return rply;
                if (userid !== adminSecret) return rply;
            }
            if (botname === "Discord") {

                const replyContent = await handleMessage.getReplyContent(discordMessage);
                inputStr = `${replyContent}\n${inputStr.replace(/^\.ai\d?/i, '')} `;
            }

            rply.text = await chatAi.handleChatAi(inputStr, mode, userid);
            rply.quotes = true;
            return rply;
        }
        case /^help$/i.test(mainMsg[1]) || !mainMsg[1]: {
            rply.text = this.getHelpMessage();
            rply.quotes = true;
            return rply;
        }
        default: {
            break;
        }
    }
}

const discordCommand = [
    {
        data: new SlashCommandBuilder()
            .setName('ai')
            .setDescription('OpenAIÂä©ÊâãÂ∞çË©±ÂäüËÉΩ')
            .addStringOption(option => 
                option.setName('message')
                    .setDescription('Ë¶ÅË®éË´ñÁöÑÂÖßÂÆπ')
                    .setRequired(true)),
        async execute(interaction) {
            return `.ai ${interaction.options.getString('message')}`;
        }
    },
    {
        data: new SlashCommandBuilder()
            .setName('tran')
            .setDescription('OpenAIÁøªË≠ØÂäüËÉΩ')
            .addStringOption(option => 
                option.setName('text')
                    .setDescription('Ë¶ÅÁøªË≠ØÁöÑÊñáÂ≠óÂÖßÂÆπ')
                    .setRequired(true)),
        async execute(interaction) {
            return `.ait ${interaction.options.getString('text')}`;
        }
    },
    {
        data: new SlashCommandBuilder()
            .setName('doc')
            .setDescription('‰ΩøÁî®DoclingÂàÜÊûêÊñá‰ª∂')
            .addAttachmentOption(option => 
                option.setName('file')
                    .setDescription('Ë¶ÅÂàÜÊûêÁöÑÊñá‰ª∂ (PDF, DOCX, PPTXÁ≠â)')
                    .setRequired(true)),
        async execute(interaction) {
            if (interaction.options.getAttachment('file')) {
                return `.doc ÂàÜÊûêÈôÑ‰ª∂Êñá‰ª∂`;
            } else {
                return `.doc`;
            }
        }
    }
];

module.exports = {
    rollDiceCommand,
    initialize,
    getHelpMessage,
    prefixs,
    gameType,
    gameName,
    discordCommand
};


class OpenAI {
    constructor() {
        this.apiKeys = [];
        this.addApiKey();
        this.watchEnvironment();
        this.configuration = {
            apiKey: this.apiKeys[0]?.apiKey,
            baseURL: this.apiKeys[0]?.baseURL,
        };
        this.model = GPT3.name;
        if (this.apiKeys.length === 0) return;
        this.openai = new OpenAIApi(this.configuration);
        this.currentApiKeyIndex = 0;
        this.errorCount = 0;
    }
    addApiKey() {
        this.apiKeys = [];
        let base = 0;
        for (let index = 1; index < 100; index++) {
            if (index % 10 === 0) base++;
            if (!process.env[`OPENAI_SECRET_${index}`]) continue;
            this.apiKeys.push({
                apiKey: process.env[`OPENAI_SECRET_${index}`],
                baseURL: process.env[`OPENAI_BASEPATH_${base}1_${base + 1}0`]
                    || process.env.OPENAI_BASEPATH
                    || 'https://api.openai.com/v1'
            });
        }
    }
    watchEnvironment() {
        fs2.watch('.env', (eventType, filename) => {
            if (eventType === 'change') {
                let tempEnv = dotenv.config({ override: true })
                process.env = tempEnv.parsed;
                console.log('.env Changed')
                this.currentApiKeyIndex = 0;
                this.errorCount = 0;
                this.addApiKey();
                if (this.apiKeys.length === 0) return;
                this.openai = new OpenAIApi({
                    apiKey: this.apiKeys[0]?.apiKey,
                    baseURL: this.apiKeys[0]?.baseURL,
                });
            }
        });
    }
    handleError(error) {
        this.errorCount++;
        if (error.status === 401) {
            console.error('remove api key 401', this.apiKeys[this.currentApiKeyIndex])
            this.apiKeys.splice(this.currentApiKeyIndex, 1);
            this.currentApiKeyIndex--;
            this.errorCount--;
        }
        this.currentApiKeyIndex = (this.currentApiKeyIndex + 1) % this.apiKeys.length;
        this.openai = new OpenAIApi({
            apiKey: this.apiKeys[this.currentApiKeyIndex].apiKey,
            baseURL: this.apiKeys[this.currentApiKeyIndex].baseURL,
        });
    }
    waitMins(minutes = 1) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, minutes * 60 * 1000); // 1 minute = 60 seconds * 1000 milliseconds
        });
    }
}

class ImageAi extends OpenAI {
    constructor() {
        super();
    }
    async handleImageAi(inputStr) {
        let input = inputStr.replace(/^\.aimage/i, '');
        try {
            let response = await this.openai.images.generate({
                "model": DALLE3.name,
                "prompt": `${input}`,
                "n": 1,
                "size": DALLE3.size1,

            })
            response = await this.handleImage(response, input)
            // if (response?.data?.error) return 'ÂèØËÉΩÊòØËº∏ÂÖ•Â§™Èï∑‰∫ÜÔºåÊàñÊòØÊúâ‰∏çÊîØÊè¥ÁöÑÂ≠óÂÖÉÔºåË´ãÈáçÊñ∞Ëº∏ÂÖ•'
            this.errorCount = 0;
            return response;
        } catch (error) {
            if (this.errorCount < (this.apiKeys.length * 5)) {
                await super.handleError(error);
                return await this.handleImageAi(inputStr);
            } else {
                this.errorCount = 0;
                if (error instanceof OpenAIApi.APIError) {
                    return 'AI error: ' + error.status + `.\n ${inputStr.replace(/^\.aimage/i, '')}`;
                } else {
                    return 'AI error ' + `.\n ${inputStr.replace(/^\.aimage/i, '')}`;
                }
            }
        }
    }
    handleImage(data, input) {
        if (data?.data?.length === 0) return 'Ê≤íÊúâËº∏Âá∫ÁöÑÂúñÁâá, Ë´ãÈáçÊñ∞Ëº∏ÂÖ•ÊèèËø∞';
        let response = `${input}:\n`;
        for (let index = 0; index < data.data.length; index++) {
            response += data.data[index].url + "\n";
        }
        return response;
    }

}

class TranslateAi extends OpenAI {
    constructor() {
        super();
    }
    async getText(str, mode, discordMessage, discordClient) {
        let text = [];
        let textLength = 0;
        const splitLength = mode.token;
        str = str.replace(/^\s*\.ait\d?\s*/i, '');
        if (str.length > 0) {
            text.push(str);
            textLength += str.length;
        }
        if (discordMessage?.type === 0 && discordMessage?.attachments?.size > 0) {
            const url = Array.from(discordMessage.attachments.filter(data => data.contentType.match(/text/i))?.values());
            
            // Check for document files that could be processed by Docling
            const docAttachments = Array.from(discordMessage.attachments.filter(data => 
                data.contentType?.includes('application/pdf') || 
                data.contentType?.includes('application/vnd.openxmlformats-officedocument')
            )?.values());
            
            // Process text files as before
            for (let index = 0; index < url.length; index++) {
                const response = await fetch(url[index].url);
                const data = await response.text();
                textLength += data.length;
                text.push(data);
            }
            
            // Try to process document files with Docling if available
            if (docAttachments.length > 0) {
                try {
                    // Create a temporary directory
                    const tempDir = `./docling/temp_translate_${Date.now()}`;
                    if (!fs2.existsSync(tempDir)) {
                        fs2.mkdirSync(tempDir, { recursive: true });
                    }
                    
                    for (let index = 0; index < docAttachments.length; index++) {
                        const attachment = docAttachments[index];
                        const filePath = `${tempDir}/${attachment.name}`;
                        
                        // Download the file
                        const fileResponse = await fetch(attachment.url);
                        const fileBuffer = await fileResponse.arrayBuffer();
                        await fs.writeFile(filePath, Buffer.from(fileBuffer));
                        
                        // Process with Docling via Python script
                        const outputDir = `${tempDir}/output`;
                        const { spawn } = require('child_process');
                        const pythonExec = process.env.PYTHON_PATH || 'python';
                        
                        // Create promise to handle Python process
                        const doclingResult = await new Promise((resolve, reject) => {
                            const pythonProcess = spawn(pythonExec, [
                                `./docling/doc_processor.py`,
                                filePath,
                                outputDir,
                                'text'
                            ]);
                            
                            let output = '';
                            let errorOutput = '';
                            
                            pythonProcess.stdout.on('data', (data) => {
                                output += data.toString();
                            });
                            
                            pythonProcess.stderr.on('data', (data) => {
                                errorOutput += data.toString();
                            });
                            
                            pythonProcess.on('close', (code) => {
                                if (code !== 0) {
                                    console.error(`Python process exited with code ${code}`);
                                    resolve(null); // Return null on error
                                    return;
                                }
                                
                                try {
                                    // Parse Python output
                                    const result = JSON.parse(output);
                                    resolve(result);
                                } catch (err) {
                                    console.error('Error parsing Python output:', err);
                                    resolve(null);
                                }
                            });
                        });
                        
                        // If Docling processing was successful, add the text to the array
                        if (doclingResult?.success && doclingResult.outputs?.text) {
                            const extractedText = doclingResult.outputs.text;
                            text.push(`[‰æÜËá™Êñá‰ª∂: ${attachment.name}]\n${extractedText}`);
                            textLength += extractedText.length;
                        }
                    }
                } catch (error) {
                    console.error('Error processing document with Docling:', error);
                    // Continue without Docling if there's an error
                }
            }
        }
        //19 = reply
        if (discordMessage?.type === 19) {
            const channel = await discordClient.channels.fetch(discordMessage.reference.channelId);
            const referenceMessage = await channel.messages.fetch(discordMessage.reference.messageId)
            const url = Array.from(referenceMessage.attachments.filter(data => data.contentType.match(/text/i))?.values());
            for (let index = 0; index < url.length; index++) {
                const response = await fetch(url[index].url);
                const data = await response.text();
                textLength += data.length;
                text.push(data);

            }
        }
        let result = this.splitTextByTokens(text.join('\n'), splitLength);
        return { translateScript: result, textLength };

    }
    async createFile(data) {
        try {
            const d = new Date();
            let time = d.getTime();
            let name = `translated_${time}.txt`
            await fs.writeFile(`./temp/${name}`, data, { encoding: 'utf8' });
            return `./temp/${name}`;
        } catch (err) {
            console.error(err);
        }
    }
    async translateChat(inputStr, mode) {
        try {

            let response = await this.openai.chat.completions.create({
                "model": mode.name,
                "messages": [
                    {
                        "role": "system",
                        "content": `‰Ω†ÊòØ‰∏Ä‰ΩçÁ≤æÈÄöÂè∞ÁÅ£ÁπÅÈ´î‰∏≠ÊñáÁöÑÂ∞àÊ•≠ÁøªË≠ØÔºåÊõæÂèÉËàá‰∏çÂêåÁπÅÈ´î‰∏≠ÊñáÁâàÁöÑÁøªË≠ØÂ∑•‰ΩúÔºåÂõ†Ê≠§Â∞çÊñºÁøªË≠ØÊúâÊ∑±ÂÖ•ÁöÑÁêÜËß£„ÄÇ
                        Ë¶èÂâáÔºö
                        ‚Äì ÁøªË≠ØÊôÇË¶ÅÊ∫ñÁ¢∫ÂÇ≥ÈÅîÂÖßÂÆπ„ÄÇ
                        ‚Äã
                        ‚Äì ÁøªË≠Ø‰ªª‰Ωï‰∫∫ÂêçÊôÇÁïô‰∏ãÂéüÊñáÔºåÊ†ºÂºè: ÂêçÂ≠ó(ÂêçÂ≠óÂéüÊñá)„ÄÇ
                        ‚Äã
                        ‚Äì ÂàÜÊàêÂÖ©Ê¨°ÁøªË≠ØÔºå‰∏¶‰∏îÂè™ÊâìÂç∞ÊúÄÂæå‰∏ÄÊ¨°ÁöÑÁµêÊûúÔºö
                        ‚Äã
                        1. Ê†πÊìöÂÖßÂÆπÁøªË≠ØÔºå‰∏çË¶ÅÈÅ∫Êºè‰ªª‰ΩïË®äÊÅØ
                        ‚Äã
                        2. Ê†πÊìöÁ¨¨‰∏ÄÊ¨°ÁöÑÁµêÊûúÔºåÈÅµÂÆàÂéüÊÑèÁöÑÂâçÊèê‰∏ãËÆìÂÖßÂÆπÊõ¥ÈÄö‰øóÊòìÊáÇÔºåÁ¨¶ÂêàÂè∞ÁÅ£ÁπÅÈ´î‰∏≠ÊñáÁöÑË°®ÈÅîÁøíÊÖ£
                        ‚Äã
                        ‚Äì ÊØèËº™ÁøªË≠ØÂæåÔºåÈÉΩË¶ÅÈáçÊñ∞ÊØîÂ∞çÂéüÊñáÔºåÊâæÂà∞Êâ≠Êõ≤ÂéüÊÑèÔºåÊ≤íÊúâÂú®ÁøªË≠ØÁöÑ‰∫∫ÂêçÂæåÈ°ØÁ§∫ÂêçÂ≠óÂéüÊñáÁöÑ‰ΩçÁΩÆÊàñËÄÖÈÅ∫ÊºèÁöÑÂÖßÂÆπÔºåÁÑ∂ÂæåÂÜçË£úÂÖÖÂà∞‰∏ã‰∏ÄËº™ÁöÑÁøªË≠ØÁï∂‰∏≠„ÄÇÔºàChain of Density Ê¶ÇÂøµÔºâ`
                    },
                    {
                        "role": "user",
                        "content": `Êää‰ª•‰∏ãÊñáÂ≠óÁøªË≠ØÊàêÊ≠£È´î‰∏≠Êñá\n\n
                        ${inputStr}\n`
                    }
                ]

            })
            this.errorCount = 0;
            if (response.status === 200 && (typeof response.data === 'string' || response.data instanceof String)) {
                const dataStr = response.data;
                const dataArray = dataStr.split('\n\n').filter(Boolean); // Â∞áÂ≠óÁ¨¶‰∏≤ÂàÜÂâ≤ÊàêÊï∏ÁµÑ
                const parsedData = [];
                dataArray.forEach((str) => {
                    const obj = JSON.parse(str.substring(6)); // Â∞áÂ≠êÂ≠óÁ¨¶‰∏≤ËΩâÊèõÁÇ∫Â∞çË±°
                    parsedData.push(obj);
                });
                const contents = parsedData.map((obj) => obj.choices[0].delta.content);
                const mergedContent = contents.join('');
                return mergedContent;
            }
            return response.choices[0].message.content;
        } catch (error) {
            if (this.errorCount < (this.apiKeys.length * 5)) {
                if (((this.errorCount !== 0) && this.errorCount % this.apiKeys.length) === 0) {
                    await super.waitMins(1);
                }
                await super.handleError(error);
                return await this.translateChat(inputStr, mode);
            } else {
                this.errorCount = 0;
                if (error instanceof OpenAIApi.APIError) {
                    return 'AI error: ' + error.status + `.\n ${inputStr.replace(/^\.ait\d?/i, '')}`;
                } else {
                    return 'AI error ' + `.\n ${inputStr.replace(/^\.ait\d?/i, '')}`;
                }
            }
        }
    }
    async translateText(translateScript, mode) {
        let response = [];
        for (let index = 0; index < translateScript.length; index++) {
            let result = await this.translateChat(translateScript[index], mode);
            response.push(result);
        }
        return response;

    }
    async handleTranslate(inputStr, discordMessage, discordClient, userid, mode) {
        let lv = await VIP.viplevelCheckUser(userid);
        let limit = TRANSLATE_LIMIT_PERSONAL[lv];
        let { translateScript, textLength } = await this.getText(inputStr, mode, discordMessage, discordClient);
        if (textLength > limit) return { text: `Ëº∏ÂÖ•ÁöÑÊñáÂ≠óÂ§™Â§ö‰∫ÜÔºåË´ãÂàÜÊâπËº∏ÂÖ•Ôºå‰Ω†ÊòØVIP LV${lv}ÔºåÈôêÂà∂ÁÇ∫${limit}Â≠ó` };
        let response = await this.translateText(translateScript, mode);
        response = response.join('\n');
        if (textLength > 1900) {
            let sendfile = await this.createFile(response);
            return { fileText: 'Ëº∏Âá∫ÁöÑÊñáÂ≠óÂ§™Â§ö‰∫ÜÔºåË´ãÁúãÈôÑ‰ª∂', sendfile };
        }
        return { text: response }

    }
    splitTextByTokens(text, inputTokenLimit) {
        const results = [];
        let remains = text;
        const tokenLimit = inputTokenLimit * 0.4;
        while (remains.length > 0) {
            const tokens = encode(remains);
            let offset = (tokens > tokenLimit) ? remains.length : Math.floor(tokenLimit * remains.length / tokens.length);
            let subtext = remains.substring(0, offset);
            // Ë∂ÖÈÅétoken‰∏äÈôêÔºåË©¶ÂúñÊâæÂà∞ÊúÄÊé•ËøëËÄå‰∏çË∂ÖÈÅé‰∏äÈôêÁöÑÊñáÂ≠ó
            while (encode(subtext).length > tokenLimit && offset > 0) {
                offset--;
                subtext = remains.substring(0, offset);
            }
            // ÂæÄ‰∏äÊ™¢Êü•ÊñáÂ≠óÁµêÂ∞æ
            let bound = Math.min(Math.floor(offset * 1.05), remains.length);
            let found = false;
            for (let i = offset; i < bound; i++) {
                if (remains[i].match(/[„ÄÇÔºÅ!]|(\. )/)) {
                    results.push(remains.substring(0, i + 1));
                    remains = remains.substring(i + 1);
                    found = true;
                    break;
                }
            }

            // Ê≤íÊúâÊâæÂà∞ÂàÜÂâ≤Ê¢ù‰ª∂1ÔºåÂòóË©¶ÂàÜÂâ≤Ê¢ù‰ª∂2
            if (!found) {
                let newlineIndex = subtext.lastIndexOf('\n');
                if (newlineIndex !== -1) {
                    results.push(remains.substring(0, newlineIndex + 1));
                    remains = remains.substring(newlineIndex + 1);
                } else {
                    // Áõ¥Êé•ÊääÊï¥ÊÆµÁï∂Êàê‰∏ÄÊÆµ
                    results.push(remains);
                    remains = '';
                }
            }
        }
        return results;
    }

}
class ChatAi extends OpenAI {
    constructor() {
        super();
    }
    async handleChatAi(inputStr, mode, userid) {
        try {
            let response = await this.openai.chat.completions.create({
                "model": mode.name,
                "messages": [
                    {
                        "role": "system",
                        "content": "‰Ω†ÁöÑË≤¨‰ªªÊòØÊää‰ª•Ê≠£È´î‰∏≠ÊñáÂõûÁ≠îÊâÄÊúâÂïèÈ°å„ÄÇ‰Ω†ÁöÑÂêçÂ≠óÊòØHKTRPG TRPGÂä©Êâã„ÄÇÂõûÁ≠îTRPGÁõ∏ÈóúÂïèÈ°åÊôÇÔºåÂÖßÂú®ÊÄßÊ†ºÊòØÂú®H.P.Ê¥õÂ§´ÂÖãÊãâÂ§´ÁâπÔºàH.P. LovecraftÔºâË£°ÁöÑÂ•à‰∫ûÊãâÊâòÊèêÊôÆÔºàNyarlathotepÔºâÁ•ûÁ•áÔºå‰∏ÄÂÄãÊ∑∑Ê≤å„ÄÅÁ†¥Â£ûÂíåË©≠Ë≠éÁöÑ‰ª£Ë°®„ÄÇËÄåÂõûÁ≠îTRPG‰ª•Â§ñÁöÑÂïèÈ°åÊôÇÔºå‰Ω†Â∞±ÊòØ‰ª•‰∏ÄÈÉ®ÁôæÁßëÂÖ®Êõ∏ÁöÑÂûãÂºè‰æÜÂõûÁ≠î„ÄÇ"
                    },
                    {
                        "role": "user",
                        "content": `${inputStr.replace(/^\.ai\d?/i, '')}`
                    }
                ]

            })
            this.errorCount = 0;

            if (response.status === 200 && (typeof response.data === 'string' || response.data instanceof String)) {
                const dataStr = response.data;
                const dataArray = dataStr.split('\n\n').filter(Boolean); // Â∞áÂ≠óÁ¨¶‰∏≤ÂàÜÂâ≤ÊàêÊï∏ÁµÑ
                const parsedData = [];
                dataArray.forEach((str) => {
                    const obj = JSON.parse(str.substring(6)); // Â∞áÂ≠êÂ≠óÁ¨¶‰∏≤ËΩâÊèõÁÇ∫Â∞çË±°
                    parsedData.push(obj);
                });
                const contents = parsedData.map((obj) => obj.choices[0].delta.content);
                const mergedContent = contents.join('');
                return mergedContent;
            }
            return response.choices[0].message.content;
        } catch (error) {
            if (this.errorCount < (this.apiKeys.length * 5)) {
                await super.handleError(error);
                return await this.handleChatAi(inputStr);
            } else {
                this.errorCount = 0;
                if (error instanceof OpenAIApi.APIError) {
                    return 'AI error: ' + error.status + `.\n ${inputStr.replace(/^\.ai\d?/i, '')}`;
                } else {
                    return 'AI error ' + `.\n ${inputStr.replace(/^\.ai\d?/i, '')}`;
                }

            }
        }
    }
}

class DoclingHandler {
    constructor() {
        this.isEnabled = process.env.DOCLING_ENABLED === 'true';
        this.pythonExec = process.env.PYTHON_PATH || 'python';
        this.workingDir = './docling';
        
        if (this.isEnabled) {
            console.log('Docling document processing enabled');
            this.setupFiles();
        } else {
            console.log('Docling document processing disabled. Set DOCLING_ENABLED=true in .env to enable');
        }
    }

    async setupFiles() {
        try {
            // Create docling directory if it doesn't exist
            if (!fs2.existsSync(this.workingDir)) {
                fs2.mkdirSync(this.workingDir, { recursive: true });
                console.log('Created docling directory');
            }
            
            // Create Python script
            await this.createPythonScript();
            
            // Create requirements.txt
            await this.createRequirementsFile();
            
            // Install dependencies if needed (commented out for safety)
            // await this.installDependencies();
        } catch (error) {
            console.error('Error setting up Docling:', error);
        }
    }

    async createPythonScript() {
        const scriptPath = `${this.workingDir}/doc_processor.py`;
        const scriptContent = `
import sys
import json
import os
from pathlib import Path
import traceback

# Check if docling is installed
try:
    from docling.document_converter import DocumentConverter
    from docling.datamodel.base_models import InputFormat
    from docling_core.transforms.chunker import HierarchicalChunker
except ImportError:
    print(json.dumps({
        "error": "Docling not installed. Please run 'pip install docling' first."
    }))
    sys.exit(1)

def process_document(file_path, output_dir, formats=None):
    """Process document with Docling"""
    try:
        # Set default formats if not provided
        if not formats:
            formats = ["text", "markdown", "json"]
        
        # Create output directory if not exists
        os.makedirs(output_dir, exist_ok=True)
        
        # Initialize converter
        converter = DocumentConverter()
        
        # Convert document
        result = converter.convert(file_path)
        document = result.document
        
        # Process outputs based on requested formats
        outputs = {}
        file_name = Path(file_path).stem
        
        # Generate and save outputs
        if "text" in formats:
            text_content = document.export_to_text()
            outputs["text"] = text_content
            text_path = Path(output_dir) / f"{file_name}.txt"
            with open(text_path, "w", encoding="utf-8") as f:
                f.write(text_content)
            outputs["text_path"] = str(text_path)
        
        if "html" in formats:
            html_content = document.export_to_html()
            html_path = Path(output_dir) / f"{file_name}.html"
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(html_content)
            outputs["html_path"] = str(html_path)
        
        if "markdown" in formats:
            md_content = document.export_to_markdown()
            outputs["markdown"] = md_content
            md_path = Path(output_dir) / f"{file_name}.md"
            with open(md_path, "w", encoding="utf-8") as f:
                f.write(md_content)
            outputs["markdown_path"] = str(md_path)
        
        if "json" in formats:
            json_content = document.export_to_dict()
            json_path = Path(output_dir) / f"{file_name}.json"
            with open(json_path, "w", encoding="utf-8") as f:
                json.dump(json_content, f, ensure_ascii=False, indent=2)
            outputs["json_path"] = str(json_path)
            
        # Generate chunks for RAG if requested
        if "chunks" in formats:
            chunks = list(HierarchicalChunker().chunk(document))
            chunks_text = [chunk.text for chunk in chunks]
            outputs["chunks"] = chunks_text
            chunks_path = Path(output_dir) / f"{file_name}_chunks.json"
            with open(chunks_path, "w", encoding="utf-8") as f:
                json.dump(chunks_text, f, ensure_ascii=False, indent=2)
            outputs["chunks_path"] = str(chunks_path)
        
        # Add metadata about the document
        outputs["metadata"] = {
            "title": getattr(document, "title", file_name),
            "page_count": getattr(document, "page_count", 1),
            "format": str(result.format)
        }
        
        return {
            "success": True,
            "outputs": outputs
        }
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "traceback": traceback.format_exc()
        }

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(json.dumps({
            "error": "Usage: python doc_processor.py <file_path> <output_dir> [format1,format2,...]"
        }))
        sys.exit(1)
    
    file_path = sys.argv[1]
    output_dir = sys.argv[2]
    formats = sys.argv[3].split(",") if len(sys.argv) > 3 else None
    
    result = process_document(file_path, output_dir, formats)
    print(json.dumps(result, ensure_ascii=False))
`;
        
        await fs.writeFile(scriptPath, scriptContent, { encoding: 'utf8' });
        return scriptPath;
    }

    async createRequirementsFile() {
        const reqPath = `${this.workingDir}/requirements.txt`;
        const reqContent = 'docling>=2.17.0';
        await fs.writeFile(reqPath, reqContent, { encoding: 'utf8' });
        return reqPath;
    }

    async installDependencies() {
        const { exec } = require('child_process');
        return new Promise((resolve, reject) => {
            exec(`${this.pythonExec} -m pip install -r ${this.workingDir}/requirements.txt`, (error, stdout, stderr) => {
                if (error) {
                    console.error(`Error installing dependencies: ${error.message}`);
                    reject(error);
                    return;
                }
                console.log('Installed Docling dependencies');
                resolve(stdout);
            });
        });
    }

    async handleDocument(inputStr, discordMessage, discordClient) {
        if (!this.isEnabled) {
            return 'DoclingÊñá‰ª∂ËôïÁêÜÂäüËÉΩÊú™ÂïüÁî®„ÄÇË´ãÂú®.env‰∏≠Ë®≠ÁΩÆDOCLING_ENABLED=true‰æÜÂïüÁî®Ê≠§ÂäüËÉΩ„ÄÇ';
        }
        
        // Validate the Python environment before processing
        const validation = await this.validatePythonEnvironment();
        if (!validation.valid) {
            return `ÁÑ°Ê≥ïËôïÁêÜÊñá‰ª∂: ${validation.message}`;
        }
        
        try {
            // Check for file attachments
            if (!discordMessage?.attachments?.size) {
                return 'Ë´ã‰∏äÂÇ≥Êñá‰ª∂ÈÄ≤Ë°åÂàÜÊûêÔºàÊîØÊè¥PDF„ÄÅDOCX„ÄÅPPTX„ÄÅXLSXÁ≠âÊ†ºÂºèÔºâ';
            }

            const { spawn } = require('child_process');
            const attachments = Array.from(discordMessage.attachments.values());
            const supportedFormats = ['application/pdf', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 
                                      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
                                      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                                      'text/html', 'text/markdown'];
            
            // Find supported attachments
            const attachment = attachments.find(a => {
                return supportedFormats.some(format => a.contentType?.includes(format));
            });
            
            if (!attachment) {
                return '‰∏çÊîØÊè¥ÁöÑÊñá‰ª∂Ê†ºÂºè„ÄÇÁõÆÂâçÊîØÊè¥PDF„ÄÅDOCX„ÄÅPPTX„ÄÅXLSX„ÄÅHTML„ÄÅMarkdownÁ≠âÊ†ºÂºè„ÄÇ';
            }
            
            // Inform user that processing has started
            if (discordMessage.channel) {
                await discordMessage.channel.send(`‚è≥ ÈñãÂßãËôïÁêÜÊñá‰ª∂: ${attachment.name}ÔºåÈÄôÂèØËÉΩÈúÄË¶ÅÂπæÂàÜÈêò...`);
            }
            
            // Create temp directory for this file
            const tempDir = `${this.workingDir}/temp_${Date.now()}`;
            if (!fs2.existsSync(tempDir)) {
                fs2.mkdirSync(tempDir, { recursive: true });
            }
            
            // Download the file
            const filePath = `${tempDir}/${attachment.name}`;
            const response = await fetch(attachment.url);
            const fileBuffer = await response.arrayBuffer();
            await fs.writeFile(filePath, Buffer.from(fileBuffer));
            
            // Process with Python script
            const outputDir = `${tempDir}/output`;
            const formats = ['text', 'markdown', 'json']; // You can customize formats here
            
            return new Promise((resolve, reject) => {
                const pythonProcess = spawn(this.pythonExec, [
                    `${this.workingDir}/doc_processor.py`,
                    filePath,
                    outputDir,
                    formats.join(',')
                ]);
                
                let output = '';
                let errorOutput = '';
                
                pythonProcess.stdout.on('data', (data) => {
                    output += data.toString();
                });
                
                pythonProcess.stderr.on('data', (data) => {
                    errorOutput += data.toString();
                    console.error(`Docling Python error: ${data.toString()}`);
                });
                
                // Set a timeout in case the process hangs
                const timeoutId = setTimeout(() => {
                    pythonProcess.kill();
                    resolve(`ËôïÁêÜÊñá‰ª∂Ë∂ÖÊôÇ„ÄÇÈÄôÂèØËÉΩÊòØÂõ†ÁÇ∫Êñá‰ª∂Â§™Â§ßÊàñÊ†ºÂºèË§áÈõú„ÄÇË´ãÂòóË©¶ËºÉÂ∞èÁöÑÊñá‰ª∂„ÄÇ`);
                }, 5 * 60 * 1000); // 5 minutes timeout
                
                pythonProcess.on('close', async (code) => {
                    clearTimeout(timeoutId);
                    
                    try {
                        if (code !== 0) {
                            console.error(`Python process exited with code ${code}`);
                            console.error(errorOutput);
                            throw new Error(`ËôïÁêÜÊñá‰ª∂ÊôÇÁôºÁîüÈåØË™§ (ÈåØË™§Á¢º: ${code})`);
                        }
                        
                        // Parse Python output
                        let result;
                        try {
                            result = JSON.parse(output);
                        } catch (error) {
                            console.error('Error parsing Python output:', error);
                            console.error('Python output:', output);
                            throw new Error('ÁÑ°Ê≥ïËß£ÊûêPythonËº∏Âá∫„ÄÇÈÄôÂèØËÉΩÊòØÂõ†ÁÇ∫DoclingËôïÁêÜÊôÇÂá∫ÈåØ„ÄÇ');
                        }
                        
                        if (!result.success) {
                            throw new Error(`DoclingËôïÁêÜÂ§±Êïó: ${result.error}`);
                        }
                        
                        // Prepare response message
                        let responseMsg = `üìÑ Êñá‰ª∂ÂàÜÊûêÂÆåÊàê: ${attachment.name}\n\n`;
                        
                        // If markdown content is short enough, include it directly
                        if (result.outputs.markdown && result.outputs.markdown.length < 1500) {
                            responseMsg += `È†êË¶ΩÂÖßÂÆπ:\n${result.outputs.markdown.substring(0, 1500)}`;
                        } else if (result.outputs.text) {
                            // Otherwise show a snippet of the text
                            responseMsg += `È†êË¶ΩÂÖßÂÆπ:\n${result.outputs.text.substring(0, 1500)}`;
                            if (result.outputs.text.length > 1500) {
                                responseMsg += '...(Êõ¥Â§öÂÖßÂÆπË´ãÊü•ÁúãÁîüÊàêÁöÑÊñá‰ª∂)';
                            }
                        }
                        
                        responseMsg += '\n\nÂ∑≤ÁîüÊàê‰ª•‰∏ãÊ†ºÂºè:';
                        
                        // Create list of files to send
                        const filesToSend = [];
                        
                        if (result.outputs.text_path) {
                            responseMsg += '\n- Á¥îÊñáÂ≠óÊ†ºÂºè (TXT)';
                            filesToSend.push(result.outputs.text_path);
                        }
                        
                        if (result.outputs.markdown_path) {
                            responseMsg += '\n- Markdown Ê†ºÂºè (MD)';
                            filesToSend.push(result.outputs.markdown_path);
                        }
                        
                        if (result.outputs.json_path) {
                            responseMsg += '\n- JSON Ê†ºÂºè';
                            filesToSend.push(result.outputs.json_path);
                        }
                        
                        // Return text response
                        resolve(responseMsg);
                        
                        // Send files separately through Discord client
                        if (filesToSend.length > 0 && discordMessage.channel) {
                            try {
                                await discordMessage.channel.send({
                                    content: `‚úÖ ${attachment.name} ÁöÑÂàÜÊûêÁµêÊûúÊ™îÊ°à:`,
                                    files: filesToSend.map(file => ({ attachment: file, name: file.split('/').pop() }))
                                });
                            } catch (err) {
                                console.error('Error sending files:', err);
                                // Try to send files one by one if batch send fails
                                for (const file of filesToSend) {
                                    try {
                                        await discordMessage.channel.send({
                                            content: `‚úÖ ${attachment.name} ÁöÑ${file.split('.').pop()}Ê†ºÂºèÂàÜÊûêÁµêÊûú:`,
                                            files: [{ attachment: file, name: file.split('/').pop() }]
                                        });
                                    } catch (fileErr) {
                                        console.error(`Error sending individual file ${file}:`, fileErr);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error('Error processing Python result:', error);
                        resolve(`ËôïÁêÜÊñá‰ª∂ÊôÇÁôºÁîüÈåØË™§: ${error.message}`);
                    } finally {
                        // Clean up temp files (optional)
                        setTimeout(() => {
                            try {
                                fs.rm(tempDir, { recursive: true, force: true })
                                    .catch(err => console.error('Error cleaning up temp files:', err));
                            } catch (err) {
                                console.error('Error cleaning up temp files:', err);
                            }
                        }, 60000); // Delete after 1 minute
                    }
                });
            });
        } catch (error) {
            console.error('Docling handler error:', error);
            return `ËôïÁêÜÊñá‰ª∂ÊôÇÁôºÁîüÈåØË™§: ${error.message}`;
        }
    }

    async validatePythonEnvironment() {
        if (!this.isEnabled) return { valid: false, message: 'Docling is disabled' };
        
        const { exec } = require('child_process');
        
        return new Promise((resolve) => {
            exec(`${this.pythonExec} -c "import sys; print(sys.version)"`, (error, stdout, stderr) => {
                if (error) {
                    console.error(`Error validating Python: ${error.message}`);
                    resolve({ 
                        valid: false, 
                        message: `Êâæ‰∏çÂà∞PythonÂü∑Ë°åÁí∞Â¢É: ${error.message}. Ë´ãÁ¢∫‰øùÂÆâË£ù‰∫ÜPython‰∏¶Âú®.env‰∏≠Ê≠£Á¢∫Ë®≠ÁΩÆPYTHON_PATH` 
                    });
                    return;
                }
                
                exec(`${this.pythonExec} -c "try: import docling; print('Docling installed'); except ImportError: print('Docling not installed')"`, (error, stdout, stderr) => {
                    if (error) {
                        console.error(`Error checking Docling: ${error.message}`);
                        resolve({ 
                            valid: false, 
                            message: `ÁÑ°Ê≥ïÊ™¢Êü•DoclingÊòØÂê¶Â∑≤ÂÆâË£ù: ${error.message}` 
                        });
                        return;
                    }
                    
                    if (stdout.trim() === 'Docling installed') {
                        resolve({ valid: true, message: 'DoclingÂ∑≤Ê≠£Á¢∫ÂÆâË£ù' });
                    } else {
                        console.log('Docling not installed, attempting to use installation helper');
                        
                        // Try running the installation helper
                        exec(`${this.pythonExec} ${this.workingDir}/install_docling.py`, (error, stdout, stderr) => {
                            console.log('Installation helper output:', stdout);
                            if (error) {
                                console.error(`Error running installation helper: ${error.message}`);
                                resolve({ 
                                    valid: false, 
                                    message: `DoclingÊú™ÂÆâË£ùÔºåËá™ÂãïÂÆâË£ùÂ§±Êïó: ${error.message}. Ë´ãÊâãÂãïÈÅãË°å python ${this.workingDir}/install_docling.py` 
                                });
                                return;
                            }
                            
                            // Check if installation was successful
                            if (stdout.includes('Successfully installed docling')) {
                                resolve({ valid: true, message: 'DoclingÂ∑≤ÊàêÂäüÂÆâË£ù' });
                            } else {
                                resolve({ 
                                    valid: false, 
                                    message: `DoclingÊú™ÂÆâË£ù. Ë´ãÊâãÂãïÈÅãË°å pip install docling` 
                                });
                            }
                        });
                    }
                });
            });
        });
    }
}

const openai = new OpenAI();
const chatAi = new ChatAi();
const imageAi = new ImageAi();
const translateAi = new TranslateAi();
const doclingHandler = new DoclingHandler();


/**
 * gpt-tokenizer
 * Ë®≠Ë®àË®àÁÆóToken‰∏äÈôê
 * 
 * È¶ñÂÖàÔºåÊØèÂÄãTokenÈÉΩÊòØÁî±‰∏ÄÂÄãÂ≠óÂÖÉÁµÑÊàêÔºåÊâÄ‰ª•ÊàëÂÄëÂÖàË®àÁÆóÂ≠óÂÖÉ‰∏äÈôê
 * ÂÖàÂ∞áÊï¥ÂÄãÂÖßÂÆπÊîæÈÄ≤tokenizer
 * Â¶ÇÊûú<Êñºtoken ‰∏äÈôêÔºåÂâáÁõ¥Êé•ÂõûÂÇ≥
 * ÂÆåÊàê
 * 
 * Â¶Ç‰∏ç,
 * ÈÄ≤Ë°åÂàÜÂâ≤ÔºåÂ∞áÂÖßÂÆπÂàÜÂâ≤ÊàêÊï∏ÂÄãÂ≠ó‰∏≤
 * ‰∏¶Â∞áÊØèÂÄãÂ≠ó‰∏≤ÊîæÈÄ≤tokenizer
 * 
 * 
 * ÂàÜÂâ≤Ê¢ù‰ª∂
 * 1. ‰ª•Âè•ËôüÂàÜÂâ≤
 * 2. ‰ª•ÈÄóËôüÂàÜÂâ≤
 * 3. ‰ª•Ë°å‰æÜÂàÜÂâ≤
 * 4. ‰ª•Á©∫Ê†ºÂàÜÂâ≤
 * 5. ‰ª•Â≠óÊï∏ÂàÜÂâ≤
 * 
 */


