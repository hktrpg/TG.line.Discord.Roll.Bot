<!DOCTYPE html>
<html lang="zh-tw">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Grimoire</title>
    <style>
        /* åƒç´ è—è¡“ä¸»é¡Œè®Šæ•¸ */
        :root {
            --pixel-scale: 2;
            --grid-size: 32px;
            --sprite-size: 32px;
            --animation-speed: 0.3s;

            /* åƒç´ èª¿è‰²ç›¤ */
            --bg-primary: #2d1b69;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --accent-primary: #ff6b6b;
            --accent-secondary: #4ecdc4;
            --accent-tertiary: #ffe66d;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --border-color: #3a3a5c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* åƒç´ ç¶²æ ¼èƒŒæ™¯ */
        .pixel-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                linear-gradient(var(--border-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--border-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            opacity: 0.1;
            z-index: -1;
        }

        /* ä¸»å®¹å™¨ - æ–°çš„ä¸‰å€åŸŸä½ˆå±€ */
        .grimoire-container {
            display: grid;
            grid-template-columns: 250px 1fr;
            grid-template-rows: 60px 1fr 100px;
            height: 100vh;
            width: 100vw;
            grid-template-areas:
                "nav status-bar"
                "nav game-area"
                "nav toolbar";
        }

        /* å°èˆªæ¬„ */
        .nav-sidebar {
            grid-area: nav;
            background: var(--bg-tertiary);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
            overflow: hidden;
        }

        .nav-sidebar.collapsed {
            width: 60px;
        }

        /* ç‹€æ…‹BAR */
        .status-bar {
            grid-area: status-bar;
            background: linear-gradient(90deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-bottom: 2px solid var(--border-color);
            height: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: flex-end;
            padding-bottom: 5px;
        }


        .status-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(76, 205, 196, 0.1), transparent);
            animation: status-scan 3s infinite;
        }

        @keyframes status-scan {
            0% { left: -100%; }
            50% { left: 100%; }
            100% { left: 100%; }
        }

        /* éŠæˆ²å€åŸŸ */
        .game-area {
            grid-area: game-area;
            position: relative;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            overflow: hidden;
        }

        /* å°èˆªé …ç›® */
        .nav-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            color: var(--text-primary);
            text-decoration: none;
            border-bottom: 1px solid var(--border-color);
            transition: all var(--animation-speed);
            cursor: pointer;
            position: relative;
        }

        .nav-item:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-left: 3px solid var(--accent-tertiary);
        }

        .nav-item.active {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-left: 3px solid var(--accent-tertiary);
        }

        .nav-icon {
            width: 24px;
            height: 24px;
            margin-right: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .nav-text {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
        }

        .nav-sidebar.collapsed .nav-text {
            display: none;
        }

        .nav-sidebar.collapsed .nav-item {
            justify-content: center;
            padding: 12px;
        }

        /* æ”¶èµ·/å±•é–‹æŒ‰éˆ• */
        .nav-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all var(--animation-speed);
            z-index: 100;
        }

        .nav-toggle:hover {
            background: var(--accent-primary);
            border-color: var(--accent-tertiary);
            color: var(--bg-primary);
        }

        /* åƒç´ ç²¾éˆ */
        .pixel-sprite {
            position: absolute;
            width: var(--sprite-size);
            height: var(--sprite-size);
            background: var(--accent-primary);
            border: 1px solid var(--accent-tertiary);
            transition: all var(--animation-speed) ease;
            z-index: 10;
        }

        /* ç²¾éˆå‹•ç•« */
        @keyframes sprite-bounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-4px) scale(1.1); }
        }

        @keyframes sprite-walk {
            0% { background-position: 0 0; }
            25% { background-position: -32px 0; }
            50% { background-position: -64px 0; }
            75% { background-position: -32px 0; }
            100% { background-position: 0 0; }
        }

        .sprite-walking {
            animation: sprite-walk 0.8s steps(4) infinite;
        }

        .sprite-active {
            animation: sprite-bounce 2s infinite;
            box-shadow: 0 0 8px var(--accent-primary);
        }

        /* ç²¾éˆæ¨£å¼è®Šé«” */
        .sprite-gm {
            background: var(--accent-secondary);
            border-color: var(--accent-tertiary);
        }

        .sprite-player {
            background: var(--accent-primary);
            border-color: var(--accent-secondary);
        }

        .sprite-npc {
            background: var(--accent-tertiary);
            border-color: var(--accent-primary);
        }



        /* åº•éƒ¨å·¥å…·æ¬„ */
        .toolbar {
            grid-area: toolbar;
            background: var(--bg-tertiary);
            border-top: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
        }

        .toolbar-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0;
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all var(--animation-speed);
        }

        .toolbar-item:hover {
            background: var(--accent-secondary);
            border-color: var(--accent-tertiary);
            color: var(--bg-primary);
        }

        /* åƒç´ æŒ‡ç¤ºå™¨ */
        .pixel-indicator {
            width: 8px;
            height: 8px;
            background: var(--accent-tertiary);
            display: inline-block;
            margin-right: 4px;
            animation: indicator-pulse 2s infinite;
        }

        @keyframes indicator-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* ç²¾éˆæ¨™ç±¤ */
        .sprite-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 2px 6px;
            font-size: 10px;
            border: 1px solid var(--border-color);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity var(--animation-speed);
        }

        .pixel-sprite:hover .sprite-label {
            opacity: 1;
        }

        /* ç§»å‹•è·¯å¾‘æŒ‡ç¤º */
        .move-path {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent-secondary);
            border-radius: 50%;
            pointer-events: none;
            animation: path-fade 1s forwards;
        }

        @keyframes path-fade {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0); }
        }

        /* éšœç¤™ç‰© */
        .obstacle {
            position: absolute;
            background: var(--accent-primary);
            border: 1px solid var(--accent-tertiary);
            pointer-events: none;
            animation: obstacle-move 8s linear infinite;
        }

        .obstacle.wall {
            width: 8px;
            height: 20px;
            background: var(--accent-primary);
        }

        .obstacle.spike {
            width: 6px;
            height: 12px;
            background: var(--accent-tertiary);
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        .obstacle.block {
            width: 12px;
            height: 16px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
        }

        @keyframes obstacle-move {
            0% { right: -20px; }
            100% { right: 100vw; }
        }

        /* ç²¾éˆè·³èºå‹•ç•« */
        .sprite-jumping {
            animation: sprite-jump 0.6s ease-out;
        }

        @keyframes sprite-jump {
            0% { transform: translateY(0) scale(1); }
            25% { transform: translateY(-15px) scale(1.1); }
            50% { transform: translateY(-20px) scale(1.2); }
            75% { transform: translateY(-15px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }

        /* æ”»æ“Šå‹•ç•« */
        .sprite-attacking {
            animation: sprite-attack 0.3s ease-out;
        }

        @keyframes sprite-attack {
            0% { transform: scale(1); }
            50% { transform: scale(1.3) rotate(15deg); }
            100% { transform: scale(1); }
        }

        /* ç ´ç¢æ•ˆæœ */
        .break-effect {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent-tertiary);
            border-radius: 50%;
            pointer-events: none;
            animation: break-particle 1s ease-out forwards;
        }

        @keyframes break-particle {
            0% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translateY(-20px);
            }
        }

        /* éŠæˆ²ç‹€æ…‹æŒ‡ç¤ºå™¨ */
        .game-status {
            position: absolute;
            top: 5px;
            right: 20px;
            font-size: 12px;
            color: var(--accent-secondary);
            font-family: 'Courier New', monospace;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div class="pixel-grid"></div>

    <div class="grimoire-container">
        <!-- å°èˆªæ¬„ -->
        <div class="nav-sidebar" id="navSidebar">
            <button class="nav-toggle" id="navToggle" title="åˆ‡æ›å°èˆªæ¬„">â—€</button>

            <div class="nav-item active" data-section="dashboard">
                <div class="nav-icon">ğŸ </div>
                <div class="nav-text">å„€è¡¨æ¿</div>
            </div>

            <div class="nav-item" data-section="campaign">
                <div class="nav-icon">ğŸ“œ</div>
                <div class="nav-text">è·‘åœ˜ç®¡ç†</div>
            </div>

            <div class="nav-item" data-section="characters">
                <div class="nav-icon">ğŸ‘¥</div>
                <div class="nav-text">è§’è‰²å¡</div>
            </div>

            <div class="nav-item" data-section="dice">
                <div class="nav-icon">ğŸ²</div>
                <div class="nav-text">æ“²éª°</div>
            </div>

            <div class="nav-item" data-section="codex">
                <div class="nav-icon">ğŸ“š</div>
                <div class="nav-text">è¬ç‰©åœ–é‘‘</div>
            </div>

            <div class="nav-item" data-section="chat">
                <div class="nav-icon">ğŸ’¬</div>
                <div class="nav-text">èŠå¤©å®¤</div>
            </div>

            <div class="nav-item" data-section="settings">
                <div class="nav-icon">âš™ï¸</div>
                <div class="nav-text">è¨­å®š</div>
            </div>
        </div>

        <!-- ç‹€æ…‹BAR -->
        <div class="status-bar" id="statusBar">
            <!-- åƒç´ ç²¾éˆå€‘ -->
            <div class="pixel-sprite sprite-gm sprite-active" id="gmSprite" style="left: 50px; top: 10px;">
                <div class="sprite-label">GM - é­”æ³•å¸«</div>
            </div>

            <div class="pixel-sprite sprite-player sprite-walking" id="player1" style="left: 120px; top: 15px;">
                <div class="sprite-label">ç©å®¶1 - æˆ°å£«</div>
            </div>

            <div class="pixel-sprite sprite-player" id="player2" style="left: 190px; top: 8px;">
                <div class="sprite-label">ç©å®¶2 - ç›œè³Š</div>
            </div>

            <div class="pixel-sprite sprite-npc" id="npc1" style="left: 260px; top: 12px;">
                <div class="sprite-label">NPC - æ‘æ°‘</div>
            </div>
        </div>

        <!-- éŠæˆ²å€åŸŸ -->
        <div class="game-area" id="gameArea">
            <!-- ç©ºçš„æ¸¸æˆåŒºåŸŸ -->
        </div>

        <!-- åº•éƒ¨å·¥å…·æ¬„ -->
        <div class="toolbar">
            <div class="toolbar-item">
                <span>ğŸ¯</span>
                <span>æ“²éª°</span>
            </div>

            <div class="toolbar-item">
                <span>ğŸ“‹</span>
                <span>è§’è‰²å¡</span>
            </div>

            <div class="toolbar-item">
                <span>ğŸ’¬</span>
                <span>èŠå¤©</span>
            </div>

            <div class="toolbar-item">
                <span>ğŸ—ºï¸</span>
                <span>åœ°åœ–</span>
            </div>

            <div class="toolbar-item" style="margin-left: auto;">
                <span>âš™ï¸</span>
                <span>è¨­å®š</span>
            </div>
        </div>
    </div>

    <script>
        // UI ç®¡ç†ç³»çµ±
        class UIManager {
            constructor() {
                this.navCollapsed = false;
                this.initNavigation();
                this.initStatusUpdates();
            }

            initNavigation() {
                const navToggle = document.getElementById('navToggle');
                const navSidebar = document.getElementById('navSidebar');

                navToggle.addEventListener('click', () => {
                    this.navCollapsed = !this.navCollapsed;
                    navSidebar.classList.toggle('collapsed');

                    // æ›´æ–°æŒ‰éˆ•åœ–ç¤º
                    navToggle.textContent = this.navCollapsed ? 'â–¶' : 'â—€';
                    navToggle.title = this.navCollapsed ? 'å±•é–‹å°èˆªæ¬„' : 'æ”¶èµ·å°èˆªæ¬„';
                });

                // å°èˆªé …ç›®é»æ“Š
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.addEventListener('click', () => {
                        document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                    });
                });
            }

            initStatusUpdates() {
                // æ¯ç§’æ›´æ–°ç‹€æ…‹
                setInterval(() => {
                    this.updateStatusBar();
                }, 1000);

            }

            updateStatusBar() {
                // ä¸å†æ›´æ–°ä»»ä½•æ˜¾ç¤ºå†…å®¹ï¼Œä¿æŒçº¯åƒç´ ä½“éªŒ
            }


        }

        // ç²¾éˆç®¡ç†ç³»çµ±
        class SpriteManager {
            constructor() {
                this.sprites = [];
                this.statusBar = document.getElementById('statusBar');
                this.isAnimating = true;
                this.isGameMode = false;
                this.obstacles = [];
                this.score = 0;
                this.gameSpeed = 2;
                this.initSprites();
                this.initGameElements();
                this.startMovementCycle();
                this.startObstacleSpawner();
            }

            initGameElements() {
                // æ·»åŠ æ¸¸æˆçŠ¶æ€æŒ‡ç¤ºå™¨
                const statusIndicator = document.createElement('div');
                statusIndicator.className = 'game-status';
                statusIndicator.id = 'gameStatus';
                statusIndicator.textContent = 'è§€å¯Ÿæ¨¡å¼';
                this.statusBar.appendChild(statusIndicator);

                // å¯åŠ¨ç¢°æ’æ£€æµ‹
                this.startCollisionDetection();
            }

            startObstacleSpawner() {
                setInterval(() => {
                    if (this.isGameMode && Math.random() < 0.4) { // 40% æ¦‚ç‡ç”Ÿæˆéšœç¢ç‰©
                        this.spawnObstacle();
                    }
                }, 3000); // æ¯3ç§’å°è¯•ç”Ÿæˆ
            }

            spawnObstacle() {
                const obstacleTypes = ['wall', 'spike', 'block'];
                const randomType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

                const obstacle = document.createElement('div');
                obstacle.className = `obstacle ${randomType}`;
                obstacle.style.bottom = '0px';
                obstacle.style.right = '-20px';

                // æ ¹æ®ç±»å‹è®¾ç½®ä¸åŒçš„èµ·å§‹ä½ç½®
                if (randomType === 'wall') {
                    obstacle.style.height = Math.random() * 15 + 10 + 'px'; // 10-25pxé«˜
                } else if (randomType === 'spike') {
                    obstacle.style.bottom = Math.random() * 10 + 'px'; // 0-10px
                } else if (randomType === 'block') {
                    obstacle.style.bottom = Math.random() * 8 + 'px'; // 0-8px
                }

                this.statusBar.appendChild(obstacle);

                // æ¸…ç†è¶…å‡ºå±å¹•çš„éšœç¢ç‰©
                setTimeout(() => {
                    if (obstacle.parentNode) {
                        obstacle.parentNode.removeChild(obstacle);
                    }
                }, 9000); // 9ç§’åæ¸…ç†
            }

            startCollisionDetection() {
                setInterval(() => {
                    if (!this.isGameMode) return;

                    this.sprites.forEach(sprite => {
                        // æ£€æŸ¥ä¸éšœç¢ç‰©çš„ç¢°æ’
                        const obstacles = this.statusBar.querySelectorAll('.obstacle');
                        obstacles.forEach(obstacle => {
                            if (this.checkCollision(sprite.element, obstacle)) {
                                this.handleCollision(sprite, obstacle);
                            }
                        });
                    });
                }, 50); // æ¯50msæ£€æµ‹ä¸€æ¬¡
            }

            checkCollision(sprite, obstacle) {
                const spriteRect = sprite.getBoundingClientRect();
                const obstacleRect = obstacle.getBoundingClientRect();

                return !(spriteRect.right < obstacleRect.left ||
                        spriteRect.left > obstacleRect.right ||
                        spriteRect.bottom < obstacleRect.top ||
                        spriteRect.top > obstacleRect.bottom);
            }

            handleCollision(sprite, obstacle) {
                const obstacleType = obstacle.className.split(' ')[1];

                if (obstacleType === 'wall' || obstacleType === 'block') {
                    // å¯ä»¥æ‰“ç ´çš„éšœç¢ç‰©
                    if (this.tryBreakObstacle(sprite, obstacle)) {
                        this.breakObstacle(obstacle);
                        this.score += 10;
                        this.updateGameStatus();
                    }
                } else if (obstacleType === 'spike') {
                    // å°–åˆº - å—ä¼¤æ•ˆæœ
                    this.spriteHurt(sprite);
                    this.score = Math.max(0, this.score - 5);
                    this.updateGameStatus();
                }
            }

            tryBreakObstacle(sprite, obstacle) {
                // æ£€æŸ¥ç²¾çµæ˜¯å¦åœ¨æ”»å‡»çŠ¶æ€
                if (sprite.element.classList.contains('sprite-attacking')) {
                    return true;
                }
                return false;
            }

            breakObstacle(obstacle) {
                // åˆ›å»ºç ´ç¢æ•ˆæœ
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'break-effect';
                    particle.style.left = (obstacle.offsetLeft + Math.random() * obstacle.offsetWidth) + 'px';
                    particle.style.top = (obstacle.offsetTop + Math.random() * obstacle.offsetHeight) + 'px';
                    this.statusBar.appendChild(particle);

                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 1000);
                }

                // ç§»é™¤éšœç¢ç‰©
                if (obstacle.parentNode) {
                    obstacle.parentNode.removeChild(obstacle);
                }
            }

            spriteHurt(sprite) {
                sprite.element.style.filter = 'brightness(2) saturate(2) hue-rotate(120deg)';
                setTimeout(() => {
                    sprite.element.style.filter = '';
                }, 300);
            }

            updateGameStatus() {
                const statusIndicator = document.getElementById('gameStatus');
                statusIndicator.textContent = `éŠæˆ²æ¨¡å¼ - åˆ†æ•¸: ${this.score}`;
            }

            spriteJump(sprite) {
                if (sprite.element.classList.contains('sprite-jumping')) return;

                sprite.element.classList.add('sprite-jumping');
                setTimeout(() => {
                    sprite.element.classList.remove('sprite-jumping');
                }, 600);
            }

            spriteAttack(sprite) {
                if (sprite.element.classList.contains('sprite-attacking')) return;

                sprite.element.classList.add('sprite-attacking');
                setTimeout(() => {
                    sprite.element.classList.remove('sprite-attacking');
                }, 300);
            }

            toggleGameMode() {
                this.isGameMode = !this.isGameMode;
                const statusIndicator = document.getElementById('gameStatus');

                if (this.isGameMode) {
                    statusIndicator.textContent = 'éŠæˆ²æ¨¡å¼ - åˆ†æ•¸: 0';
                    this.score = 0;
                    // æ¸…é™¤æ‰€æœ‰ç°æœ‰éšœç¢ç‰©
                    const obstacles = this.statusBar.querySelectorAll('.obstacle');
                    obstacles.forEach(obstacle => {
                        if (obstacle.parentNode) {
                            obstacle.parentNode.removeChild(obstacle);
                        }
                    });
                } else {
                    statusIndicator.textContent = 'è§€å¯Ÿæ¨¡å¼';
                    // æ¸…é™¤æ‰€æœ‰éšœç¢ç‰©
                    const obstacles = this.statusBar.querySelectorAll('.obstacle');
                    obstacles.forEach(obstacle => {
                        if (obstacle.parentNode) {
                            obstacle.parentNode.removeChild(obstacle);
                        }
                    });
                }
            }

            initSprites() {
                // åˆå§‹åŒ–æ¸¸æˆå…ƒç´ 
                this.initGameElements();

                // åˆå§‹åŒ–ç¾æœ‰çš„ç²¾éˆ
                document.querySelectorAll('.pixel-sprite').forEach((sprite, index) => {
                    this.sprites.push({
                        element: sprite,
                        id: sprite.id || `sprite-${index}`,
                        x: parseInt(sprite.style.left) || 0,
                        y: parseInt(sprite.style.top) || 0,
                        targetX: null,
                        targetY: null,
                        speed: 2,
                        isMoving: false
                    });
                });
            }

            moveSprite(sprite, targetX, targetY) {
                if (!this.isAnimating) return;

                // é™åˆ¶åœ¨status-barèŒƒå›´å†…
                const statusBar = document.getElementById('statusBar');
                const maxX = statusBar.clientWidth - 32; // ç²¾çµå®½åº¦
                const maxY = statusBar.clientHeight - 32; // ç²¾çµé«˜åº¦

                sprite.targetX = Math.max(0, Math.min(maxX, targetX));
                sprite.targetY = Math.max(0, Math.min(maxY, targetY));
                sprite.isMoving = true;

                // æ·»åŠ ç§»å‹•è·¯å¾‘æŒ‡ç¤º
                this.showMovePath(sprite.x, sprite.y, sprite.targetX, sprite.targetY);
            }

            showMovePath(fromX, fromY, toX, toY) {
                const pathPoint = document.createElement('div');
                pathPoint.className = 'move-path';
                pathPoint.style.left = (toX + 16) + 'px'; // å±…ä¸­
                pathPoint.style.top = (toY + 16) + 'px';

                const statusBar = document.getElementById('statusBar');
                statusBar.appendChild(pathPoint);

                // è‡ªå‹•æ¸…ç†
                setTimeout(() => {
                    if (pathPoint.parentNode) {
                        pathPoint.parentNode.removeChild(pathPoint);
                    }
                }, 1000);
            }

            updateSpritePositions() {
                this.sprites.forEach(sprite => {
                    if (sprite.isMoving && sprite.targetX !== null && sprite.targetY !== null) {
                        const dx = sprite.targetX - sprite.x;
                        const dy = sprite.targetY - sprite.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < sprite.speed) {
                            // æŠµé”ç›®æ¨™
                            sprite.x = sprite.targetX;
                            sprite.y = sprite.targetY;
                            sprite.targetX = null;
                            sprite.targetY = null;
                            sprite.isMoving = false;
                            sprite.element.classList.remove('sprite-walking');
                        } else {
                            // ç¹¼çºŒç§»å‹•
                            const ratio = sprite.speed / distance;
                            sprite.x += dx * ratio;
                            sprite.y += dy * ratio;
                            sprite.element.classList.add('sprite-walking');
                        }

                        sprite.element.style.left = sprite.x + 'px';
                        sprite.element.style.top = sprite.y + 'px';
                    }
                });
            }

            startMovementCycle() {
                setInterval(() => {
                    this.updateSpritePositions();
                }, 50); // 20 FPS

                // æ¯5ç§’éš¨æ©Ÿç§»å‹•ä¸€å€‹ç²¾éˆ
                setInterval(() => {
                    if (this.isAnimating && Math.random() < 0.3) { // 30% æ©Ÿç‡
                        const randomSprite = this.sprites[Math.floor(Math.random() * this.sprites.length)];
                        const statusBar = document.getElementById('statusBar');
                        const newX = Math.random() * (statusBar.clientWidth - 32);
                        const newY = Math.random() * (statusBar.clientHeight - 32);
                        this.moveSprite(randomSprite, newX, newY);
                    }
                }, 5000);
            }

            toggleAnimations() {
                this.isAnimating = !this.isAnimating;
                if (!this.isAnimating) {
                    document.querySelectorAll('.pixel-sprite').forEach(sprite => {
                        sprite.classList.remove('sprite-walking', 'sprite-active');
                    });
                } else {
                    document.querySelectorAll('.pixel-sprite.sprite-gm').forEach(sprite => {
                        sprite.classList.add('sprite-active');
                    });
                }
            }

            addSprite(type = 'player') {
                const statusBar = document.getElementById('statusBar');
                const newX = Math.random() * (statusBar.clientWidth - 32);
                const newY = Math.random() * (statusBar.clientHeight - 32);

                const sprite = document.createElement('div');
                sprite.className = `pixel-sprite sprite-${type}`;
                sprite.style.left = newX + 'px';
                sprite.style.top = newY + 'px';

                const label = document.createElement('div');
                label.className = 'sprite-label';
                label.textContent = `æ–°å¢${type === 'player' ? 'ç©å®¶' : type === 'npc' ? 'NPC' : 'GM'}`;
                sprite.appendChild(label);

                statusBar.appendChild(sprite);

                const spriteData = {
                    element: sprite,
                    id: `new-sprite-${Date.now()}`,
                    x: newX,
                    y: newY,
                    targetX: null,
                    targetY: null,
                    speed: 2,
                    isMoving: false
                };

                this.sprites.push(spriteData);
                return spriteData;
            }

            resetPositions() {
                const basePositions = [
                    { x: 50, y: 10 },   // GM
                    { x: 120, y: 15 },  // Player 1
                    { x: 190, y: 8 },   // Player 2
                    { x: 260, y: 12 }   // NPC
                ];

                this.sprites.forEach((sprite, index) => {
                    const pos = basePositions[index] || { x: 50 + (index * 70), y: 10 };
                    sprite.x = pos.x;
                    sprite.y = pos.y;
                    sprite.targetX = null;
                    sprite.targetY = null;
                    sprite.isMoving = false;

                    sprite.element.style.left = pos.x + 'px';
                    sprite.element.style.top = pos.y + 'px';
                    sprite.element.classList.remove('sprite-walking');
                });
            }
        }

        // åˆå§‹åŒ–
        const spriteManager = new SpriteManager();


        // é»æ“Šç²¾éˆç§»å‹•æˆ–æ§åˆ¶
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('pixel-sprite')) {
                if (spriteManager.isGameMode) {
                    // æ¸¸æˆæ¨¡å¼ï¼šç‚¹å‡»ç²¾çµè¿›è¡Œæ”»å‡»
                    const spriteData = spriteManager.sprites.find(s => s.element === e.target);
                    if (spriteData) {
                        spriteManager.spriteAttack(spriteData);
                    }
                } else {
                    // è§‚å¯Ÿæ¨¡å¼ï¼šç‚¹å‡»ç§»åŠ¨ç²¾çµ
                    const rect = document.getElementById('statusBar').getBoundingClientRect();
                    const targetX = e.clientX - rect.left - 16; // å±…ä¸­
                    const targetY = e.clientY - rect.top - 16;

                    const spriteData = spriteManager.sprites.find(s => s.element === e.target);
                    if (spriteData) {
                        spriteManager.moveSprite(spriteData, targetX, targetY);
                    }
                }
            }
        });

        // éµç›¤æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            const gmSprite = spriteManager.sprites.find(s => s.element.id === 'gmSprite');
            if (!gmSprite) return;

            let newX = gmSprite.x;
            let newY = gmSprite.y;
            const moveDistance = 32; // ä¸€å€‹ç¶²æ ¼

            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (this.isGameMode) {
                        // æ¸¸æˆæ¨¡å¼ï¼šè·³è·ƒ
                        this.spriteJump(gmSprite);
                    } else {
                        newY -= moveDistance;
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    newY += moveDistance;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    newX -= moveDistance;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (this.isGameMode) {
                        // æ¸¸æˆæ¨¡å¼ï¼šæ”»å‡»
                        this.spriteAttack(gmSprite);
                    } else {
                        newX += moveDistance;
                    }
                    break;
                case ' ':
                case 'Space':
                    // ç©ºæ ¼é”®åˆ‡æ¢æ¸¸æˆæ¨¡å¼
                    this.toggleGameMode();
                    break;
            }

            // é‚Šç•Œæª¢æŸ¥ - åœ¨status-barèŒƒå›´å†…
            const statusBar = document.getElementById('statusBar');
            newX = Math.max(0, Math.min(newX, statusBar.clientWidth - 32));
            newY = Math.max(0, Math.min(newY, statusBar.clientHeight - 32));

            if (newX !== gmSprite.x || newY !== gmSprite.y) {
                spriteManager.moveSprite(gmSprite, newX, newY);
            }
        });

        // è¦–çª—èª¿æ•´å¤§å°è™•ç†
        window.addEventListener('resize', () => {
            // å¯ä»¥æ·»åŠ éŸ¿æ‡‰å¼èª¿æ•´é‚è¼¯
        });

        // è¼‰å…¥å®Œæˆæç¤º
        console.log('Pixel Grimoire loaded');
        console.log('ğŸ’¡ ä½¿ç”¨ WASD æˆ–æ–¹å‘éµæ§åˆ¶ GM ç²¾éˆ');
        console.log('ğŸ‘† é»æ“Šç²¾éˆå¯å°‡å…¶ç§»å‹•åˆ°è©²ä½ç½®');
    </script>
</body>
</html>
